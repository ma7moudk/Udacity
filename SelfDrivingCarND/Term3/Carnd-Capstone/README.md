[//]: # (Image References)

[image1]: ./imgs/final-project-ros-graph-v2.png "Architecture"
[image2]: ./imgs/model.png "Classification Model"
[image3]: ./images/trans_right.png "Random Noise"
[image4]: ./MyTestTrafficSigns/max70_roadbg.png "Traffic Sign 1"


# Programming a real self-driving car
## Self-Driving Car Engineer Nanodegree Capstone project
### Team "Udanomous"

_Team members :_
 
| Name          | email                     |
| ------------- | ------------------------- |
| Mahmoud Kamel | mahmoudkamel2014@gmail.com|
| Longxing Tan  | longxing.tan@daimler.com  |
| Khaled Zoheir | khaled.zoheir.kz@gmail.com|
| Chun Hsien Ho | Steveho183532@gmail.com   |
| Emile Papillon| epapillon@live.ca         | 

_Version_

| Version       | details          |
| ------------- |:----------------:|
| v1.0          | first submission |

Copyrights disclaimer : 
Some code or data was used from the web . The following websites were the source of this code and data:

* Autoware provides pure-pursuit waypoint follower https://github.com/CPFL/Autoware (author : Autoware)
* The traffic light detection is using a model pretrained on the COCO dataset (http://cocodataset.org/)  and available at http://download.tensorflow.org/models/object_detection/ssd_mobilenet_v1_coco_11_06_2017.tar.gz

---

## Programming a self-driving car : implementation

### ROS System Architecture

The following figure shows the architecture implemented, as suggested by Udacity. It contains a _perception_ subsystem consisting of the following nodes:
 
* Traffic light detection : Responsible of detecting traffic lights and classifying them. If the light is green, the car is free to circulate. Otherwise it must stop. The TL-Detector publishes the waypoint where the traffic lights are detected and the state of the traffic lights.  

The _Planning_ subsystem contains the following nodes :

* Waypoint loader : Initially, waypoints are published and loaded into the self-driving car system by the waypoint loader.
* Waypoint updater node : This node provides a set of 50 waypoints to be driven in front of the vehicle. The waypoint updater node is also responsible to take the traffic light waypoints and ramp-down the target velocity to stop at a target waypoint in case a red light is detected. 

Finally, the _Control_ subsystem consists of :

* Waypoint follower node : The waypoint follower provides target states for each waypoints. It is implemented as a pure-pursuit algorithm and provided by Autoware (see copyrights notice at the beginning of this document)

* Drive-by-wire (DBW) node : The drive by wire is the interface with the actuators and it publishes the brake, throttle and steering commands. It is implemented using a PID controller with target velocities (linear and angular) as twist commands. 


The simulator receives actuator commands and provides sensor data.

### Architecture Diagram :

![alt text][image1]

### Nodes implementation

#### Traffic light detection 

The traffic light detection uses a tensorflow model pretrained on the COCO dataset that returns a set of corners delimiting the portion of the image where traffic light s are found. This information is then used by a model made in Keras and trained on the data provided in bag files by Udacity to lear to classify lights as 0 : red, 1: yellow or 2: green. 

* 32 x 32 pixel squares are generated by the detector model
* A keras model then uses the 32 x 32 pixels portions of the original frame to classify the traffic light according to its state. 
* The final output are one-hot encoded labels which are then used to command the vehicle to stop if a light is classified red.

Keras Model : 

![alt text][image2]


#### Path planning

The path planning uses a K dimension tree algorithm from sklearn library to find the next waypoint and appends a list of 50 waypoints ahead of the vehicle. This node also receives the traffic light waypoints and modifies the target velocity of waypoints ahead in order to stop at red traffic lights.

#### Control 

The control subsystem is implemented using a PID. It consists of the waypoint follower node and the DBW node. The waypoint follower is responsible of defining target speed and angular velocity that are optimal to follow the target trajectory. It implements a pure pursuit waypoint following method. The waypoints generated are used by the DBW node that is implemented using a PID to issue the right throttle, brake and steering commands to follow the planned route. 

## Udacity Original README.md file contents

This is the project repo for the final project of the Udacity Self-Driving Car Nanodegree: Programming a Real Self-Driving Car. For more information about the project, see the project introduction [here](https://classroom.udacity.com/nanodegrees/nd013/parts/6047fe34-d93c-4f50-8336-b70ef10cb4b2/modules/e1a23b06-329a-4684-a717-ad476f0d8dff/lessons/462c933d-9f24-42d3-8bdc-a08a5fc866e4/concepts/5ab4b122-83e6-436d-850f-9f4d26627fd9).

Please use **one** of the two installation options, either native **or** docker installation.

### Native Installation

* Be sure that your workstation is running Ubuntu 16.04 Xenial Xerus or Ubuntu 14.04 Trusty Tahir. [Ubuntu downloads can be found here](https://www.ubuntu.com/download/desktop).
* If using a Virtual Machine to install Ubuntu, use the following configuration as minimum:
  * 2 CPU
  * 2 GB system memory
  * 25 GB of free hard drive space

  The Udacity provided virtual machine has ROS and Dataspeed DBW already installed, so you can skip the next two steps if you are using this.

* Follow these instructions to install ROS
  * [ROS Kinetic](http://wiki.ros.org/kinetic/Installation/Ubuntu) if you have Ubuntu 16.04.
  * [ROS Indigo](http://wiki.ros.org/indigo/Installation/Ubuntu) if you have Ubuntu 14.04.
* [Dataspeed DBW](https://bitbucket.org/DataspeedInc/dbw_mkz_ros)
  * Use this option to install the SDK on a workstation that already has ROS installed: [One Line SDK Install (binary)](https://bitbucket.org/DataspeedInc/dbw_mkz_ros/src/81e63fcc335d7b64139d7482017d6a97b405e250/ROS_SETUP.md?fileviewer=file-view-default)
* Download the [Udacity Simulator](https://github.com/udacity/CarND-Capstone/releases).

### Docker Installation
[Install Docker](https://docs.docker.com/engine/installation/)

Build the docker container
```bash
docker build . -t capstone
```

Run the docker file
```bash
docker run -p 4567:4567 -v $PWD:/capstone -v /tmp/log:/root/.ros/ --rm -it capstone
```

### Port Forwarding
To set up port forwarding, please refer to the [instructions from term 2](https://classroom.udacity.com/nanodegrees/nd013/parts/40f38239-66b6-46ec-ae68-03afd8a601c8/modules/0949fca6-b379-42af-a919-ee50aa304e6a/lessons/f758c44c-5e40-4e01-93b5-1a82aa4e044f/concepts/16cf4a78-4fc7-49e1-8621-3450ca938b77)

### Usage

1. Clone the project repository
```bash
git clone https://github.com/udacity/CarND-Capstone.git
```

2. Install python dependencies
```bash
cd CarND-Capstone
pip install -r requirements.txt
```
3. Make and run styx
```bash
cd ros
catkin_make
source devel/setup.sh
roslaunch launch/styx.launch
```
4. Run the simulator

### Real world testing
1. Download [training bag](https://s3-us-west-1.amazonaws.com/udacity-selfdrivingcar/traffic_light_bag_file.zip) that was recorded on the Udacity self-driving car.
2. Unzip the file
```bash
unzip traffic_light_bag_file.zip
```
3. Play the bag file
```bash
rosbag play -l traffic_light_bag_file/traffic_light_training.bag
```
4. Launch your project in site mode
```bash
cd CarND-Capstone/ros
roslaunch launch/site.launch
```
5. Confirm that traffic light detection works on real life images
